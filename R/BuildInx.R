
#' Check input and score and scale DE stats.
#'
#' This function takes differential expression gene statistics from scRNAseq
#' data representing a cell type as a dataframe, and assigns scaled scores to
#' the statistic of choice. This is used to rank nodes and edges by differential
#' expression when viewing the bipartite ligand-receptor plots.
#'
#' @param gdb A data frame representing gene statistics from a cell type, where
#'   each row is a gene with official gene symbols as row names. Variables
#'   should be appropriately named statistics or annotations to be included in
#'   the resulting node metadata.
#' @param DEmagn A character vector of length 1 representing the variable name
#'   in the GeneStatList data frames carrying information on the magnitude and
#'   direction of the change of expression for the node (gene) in each cell
#'   type. This is generally a signed logFC or gene expression ratio.
#' @param DEstat A character vector of length 1 representing the variable name
#'   in the GeneStatList data frames carrying information on the statistical
#'   significance of expression change. This is generally a corrected p-value.
#'

CalcDEscaled <- function(gdb,DEmagn,DEstat) {
  if (any( is.na(gdb[[DEmagn]]) )) {
    stop(paste("This function doesn't tolerate missing",
               DEmagn,"values."))
  }
  if (any( is.na(gdb[[DEstat]]) )) {
    stop(paste("This function doesn't tolerate missing",
               DEstat,"values."))
  }
  return(sapply(gdb[[DEmagn]],function(X) {
    if (X == Inf) {
      1.1
    } else if (X == -Inf) {
      -1.1
    } else {
      X / switch(as.character(X >= 0),
                 "TRUE"=max(gdb[[DEmagn]][!is.infinite(gdb[[DEmagn]])]),
                 "FALSE"=min(gdb[[DEmagn]][!is.infinite(gdb[[DEmagn]])]) * -1)
    }
  }))
}


CheckExpr <- function(gdb,expr) {
  stop("Only DE scoring is supported right now. GeneStatistic argument must be provided.")
}

#' Build cell-cell interaction edge list from scored cell-type statistics
#'
#'
#' @param GeneStatList A named list of dataframes. Each list element should
#'   represent a cell type / cluster to be included in the interaction network,
#'   and should be named accordingly. List elements should contain data frames
#'   where each row is a gene with official gene symbols as row names. Variables
#'   should be appropriately named statistics or annotations to be included in
#'   the resulting node metadata. Variable names should be consistent between
#'   list elements.
#' @param GeneMagnitude A character vector of length 1 representing the variable
#'   name in the GeneStatList data frames carrying information on the magnitude
#'   (and direction of the change) of expression for the node (gene) in each
#'   cell type. This is either a measure of expression (generally mean
#'   expression or detection rate) or a measure of change (signed log expression
#'   ratio a.k.a. logFC).
#' @param GeneStatistic Optional. A character vector of length 1 representing
#'   the variable name in the GeneStatList data frames carrying information on
#'   the statistical significance of expression change. This is generally a
#'   corrected p-value.
#' @param Species Default='hsapiens'. The species of the source data. One of
#'   'hsapiens' or 'mmusculus'. Note that the ligand-receptor database was built
#'   for human, and the mouse version is generated by homology mapping (only
#'   using uniquely mapped homologues).
#'
#' @export

BuildCCInx <- function(GeneStatList,
                       GeneMagnitude,
                       GeneStatistic,
                       Species="hsapiens") {
  if (length(names(GeneStatList)) != length(GeneStatList)) {
    stop("GeneStatList must be a named list where names are cell types.")
  }
  if (any(duplicated(names(GeneStatList)))) {
    stop("GeneStatList names must be unique.")
  }
  if (any(grepl("_",names(GeneStatList)))) {
    stop("GeneStatList names must not contain '_' due to internal naming conventions.")
  }
  if (any(grepl("~",names(GeneStatList)))) {
    stop("GeneStatList names must not contain '~' due to internal naming conventions.")
  }
  message("Scaling node weights per cell type...")
  if (missing(GeneStatistic)) {
    temp_scaled <- pbapply::pbsapply(X=GeneStatList,
                                     FUN=CheckExpr,
                                     expr=GeneMagnitude,
                                     simplify=F)
  } else {
    temp_scaled <- pbapply::pbsapply(X=GeneStatList,
                                     FUN=CalcDEscaled,
                                     DEmagn=GeneMagnitude,
                                     DEstat=GeneStatistic,
                                     simplify=F)
  }
  inx <- list()
  message("Building node metadata...")
  temp_cellNames <- names(GeneStatList)
  inx$nodes <- do.call(rbind,GeneStatList)
  temp_rownames <- strsplit(rownames(inx$nodes),".",fixed=T)
  temp_gene <- sapply(temp_rownames,function(X) paste(X[-1],collapse="."))
  temp_cellType <- sapply(temp_rownames,function(X) X[1])

  switch(Species,
         hsapiens=load(system.file("LigRecDB_RData/BaderCCIeditedbyBI.RData",
                                   package="CCInx")),
         mmusculus=load(system.file("LigRecDB_RData/BaderCCIeditedbyBI_mouse.RData",
                                    package="CCInx")),
         stop("Species must be one of 'hsapiens' or 'mmusculus'."))
  if (!any(temp_gene %in% rownames(geneInfo))) {
    stop("Rownames of each entry in GeneStatList must be official gene symbols.")
  }
  temp_proteinType <- geneInfo[temp_gene,"protein_type"]
  inx$nodes <- cbind(data.frame(node=paste(temp_gene,temp_cellType,sep="_"),
                                gene=temp_gene,
                                cellType=temp_cellType,
                                proteinType=temp_proteinType,
                                nodeWeight=unlist(temp_scaled),
                                stringsAsFactors=F),
                     inx$nodes)
  rownames(inx$nodes) <- inx$nodes$node
  inx$nodes <- inx$nodes[!is.na(inx$nodes$proteinType),]

  tempCN <- c()
  for (a in temp_cellNames) {
    for (b in temp_cellNames) {
      temp <- paste(sort(c(a,b)),collapse="~")
      if (!temp %in% tempCN) {
        tempCN <- append(tempCN,temp)
      }
    }
  }
  rm(a,b)
  tempComp <- strsplit(tempCN,"~")
  names(tempComp) <- tempCN

  message("Building edge list...")
  inx$edges <- pbapply::pbsapply(tempComp,function(Z) {
    a <- Z[1]; b <- Z[2]
    if (sum(inx$nodes$cellType == a) < 1 |
        sum(inx$nodes$cellType == b) < 1) {
      return(NULL)
    }

    keysAB <- inxDB$key[inxDB$nodeA %in% inx$nodes$gene[inx$nodes$cellType == a] &
                          inxDB$nodeB %in% inx$nodes$gene[inx$nodes$cellType == b]]
    edgesAB <- data.frame(
      sapply(strsplit(keysAB,"_"),function(X)
        paste(paste(X[1],a,sep="_"),paste(X[2],b,sep="_"),sep="~")),
      t(sapply(strsplit(keysAB,"_"),function(X)
        c(paste(X[1],a,sep="_"),paste(X[2],b,sep="_")))),
      stringsAsFactors=F)
    colnames(edgesAB) <- c("key","nodeA","nodeB")
    rownames(edgesAB) <- edgesAB$key

    keysBA <- inxDB$key[inxDB$nodeA %in% inx$nodes$gene[inx$nodes$cellType == b] &
                          inxDB$nodeB %in% inx$nodes$gene[inx$nodes$cellType == a]]
    edgesBA <- data.frame(
      sapply(strsplit(keysBA,"_"),function(X)
        paste(paste(X[2],a,sep="_"),paste(X[1],b,sep="_"),sep="~")),
      t(sapply(strsplit(keysBA,"_"),function(X)
        c(paste(X[2],a,sep="_"),paste(X[1],b,sep="_")))),
      stringsAsFactors=F)
    colnames(edgesBA) <- c("key","nodeA","nodeB")
    rownames(edgesBA) <- edgesBA$key

    return(rbind(edgesAB,edgesBA))
  },simplify=F)
  inx$edges <- do.call(rbind,inx$edges)
  rownames(inx$edges) <- inx$edges$key
  inx$edges <- inx$edges[,2:3]
  inx$edges$edgeWeight <- rowMeans(cbind(inx$nodes[inx$edges$nodeA,"nodeWeight"],
                                         inx$nodes[inx$edges$nodeB,"nodeWeight"]))

  attr(inx,"GeneMagnitude") <- GeneMagnitude
  attr(inx,"GeneStatistic") <- GeneStatistic

  return(inx)
}

